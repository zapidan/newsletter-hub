-- Create subscription_plans table
CREATE TABLE IF NOT EXISTS public.subscription_plans (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    monthly_price DECIMAL(10, 2) NULL,
    yearly_price DECIMAL(10, 2) NULL,
    max_sources INTEGER NOT NULL,
    max_newsletters_per_day INTEGER NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create user_subscriptions table
CREATE TABLE IF NOT EXISTS public.user_subscriptions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    plan_id BIGINT NOT NULL REFERENCES public.subscription_plans(id),
    billing_cycle VARCHAR(10) NOT NULL CHECK (billing_cycle IN ('monthly', 'yearly')),
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'canceled', 'expired')),
    current_period_start TIMESTAMP WITH TIME ZONE NOT NULL,
    current_period_end TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create daily_counts table
CREATE TABLE IF NOT EXISTS public.daily_counts (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    date DATE NOT NULL DEFAULT (timezone('utc'::text, now()))::date,
    sources_count INTEGER NOT NULL DEFAULT 0,
    newsletters_count INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT unique_user_date UNIQUE (user_id, date)
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_daily_counts_user_id ON public.daily_counts(user_id);
CREATE INDEX IF NOT EXISTS idx_daily_counts_date ON public.daily_counts(date);
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_user_id ON public.user_subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_user_subscriptions_plan_id ON public.user_subscriptions(plan_id);

-- Insert initial subscription plans
INSERT INTO public.subscription_plans 
    (name, monthly_price, yearly_price, max_sources, max_newsletters_per_day) 
VALUES 
    ('Free', NULL, NULL, 5, 5),
    ('Pro', 9.99, 99.99, 20, 20),
    ('Enterprise', 49.99, 499.99, 100, 100)
ON CONFLICT DO NOTHING;

-- Enable RLS on new tables
ALTER TABLE public.subscription_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.daily_counts ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for subscription_plans (public read)
CREATE POLICY "Enable read access for all users" 
ON public.subscription_plans 
FOR SELECT 
USING (true);

-- Create RLS policies for user_subscriptions
CREATE POLICY "Users can view their own subscriptions"
ON public.user_subscriptions
FOR SELECT
USING (auth.uid() = user_id);

-- Create RLS policies for daily_counts
CREATE POLICY "Users can view their own daily counts"
ON public.daily_counts
FOR SELECT
USING (auth.uid() = user_id);

-- Create function to update updated_at timestamps
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create triggers for updated_at
CREATE TRIGGER set_subscription_plans_updated_at
BEFORE UPDATE ON public.subscription_plans
FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER set_user_subscriptions_updated_at
BEFORE UPDATE ON public.user_subscriptions
FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER set_daily_counts_updated_at
BEFORE UPDATE ON public.daily_counts
FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
